import _ from 'lodash';
import showdown from 'showdown';

import * as 玩家管理器 from './player/玩家管理器.js';
import { getDecimalPrecision } from './utils.js';
import { StatType } from './combat/战斗属性.js';
import 装备 from './items/装备.js';

const config = {
  生命条格式: '生命值: {value} / {total}',
  魔法条格式: '魔法值: {value} / {total}',
  经验条格式: '经验值: {value} / {total}',
  攻击条格式: '下次攻击: {value} / {total}',
  默认进度条格式: '{value} / {total}',
};

const githubMarkdownCSS = fetch(
  'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css',
)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`Failed to load CSS due to response error: Status ${response.status}`);
    }
    return response.text();
  })
  .catch((error) => new Error(`Error while fetching GitHub Markdown CSS ${error.message}`));
/**
 * 使用了Shadow DOM，所以外部的CSS不会影响到内部，反之亦然。
 * @param {string} url
 * @param {JQuery<HTMLElement>} parent
 */
const loadAndRenderMarkdown = async (url, parent) => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const markdown = await response.text();
    const converter = new showdown.Converter();
    const html = converter.makeHtml(markdown);

    const parentElement = parent[0];
    const shadowRoot = parentElement.attachShadow({ mode: 'open' });
    const css = await githubMarkdownCSS;
    if (css instanceof Error) {
      throw css;
    }
    const style = document.createElement('style');
    style.textContent = css;
    const div = document.createElement('div');
    div.className = 'markdown-body'; // Assume GitHub CSS expects this class
    div.innerHTML = html;
    shadowRoot.append(style, div);
  } catch (error) {
    console.error('Failed to generate markdown', error);
    parent.html(`<p>生成markdown文件失败。</p>`);
  }
};

const wrapHtml = (htmlString, tags) => {
  // 单个标签
  if (_.isString(tags)) {
    return `<${tags}>${htmlString}</${tags}>`;
  }
  let result = htmlString;
  // 从最内层标签开始包裹
  for (let i = tags.length - 1; i >= 0; i--) {
    if (_.isString(tags[i])) {
      result = `<${tags[i]}>${result}</${tags[i]}>`;
    } else {
      const { name, settings } = tags[i];
      result = `<${name} ${settings}}>${result}</${name}>`;
    }
  }
  return result;
};

// Clean up HTML string
// Generated by ChatGPT as I'm not a regex expert
const compressHTML = (htmlString) =>
  htmlString
    .replace(/>\s+|\s+</g, (m) => m.trim()) // Remove spaces around tags
    .replace(/(\r\n|\n|\r)\s*/gm, '') // Remove all newlines and spaces starting a newline
    .trim();

const changeTab = (tabPath) => {
  $.tab('change tab', tabPath);
  // 上面的函数不会更改tab的active状态，所以我们手动更改
  $(`a[data-tab="${tabPath}"]`).addClass('active');
  $(`a[data-tab="${tabPath}"]`).siblings().filter('[data-tab]').removeClass('active');
};

const labelHTML = (title, content, className = '', inline = false) => {
  const settings = `class="ui ${className} horizontal label"`;
  return `
    ${wrapHtml(title, [{ name: inline ? 'span' : 'div', settings }])}
    ${content != null ? content : ''}
    `;
};

const genLabel = (title, content, className = '') => {
  const label = $(labelHTML(title, content, className));
  return label;
};

const progressBarHTML = ({ id, className = '', color = '', label = '', value = 0, maxValue = 1 }) =>
  `
  <div ${id ? `id="${id}"` : ''} class="ui ${color} progress active ${className}" data-percent="${
    (value / maxValue) * 100
  }">
    <div class="bar">
      <div class="progress"></div>
    </div>
    <div class="label">${label}</div>
  </div>
  `;

const genProgressBar = ({
  id,
  className = '',
  parent,
  color = '',
  label = '', // 默认标签。可忽略。只在被更新前（或更新时没有format）有用。
  value = 0,
  maxValue = 1,
  format,
}) => {
  const bar = $(progressBarHTML({ id, className, color, label, value, maxValue }));
  // 初始化进度条
  bar.progress(format ? { text: { active: format } } : {});
  parent.append(bar);
  return bar;
};

const updateProgressBar = (bar, value, maxValue, format = '{value} / {total}', precision = 0) => {
  const element = _.isString(bar) ? $(bar) : bar;
  let percent = (value / maxValue) * 100;
  // 边缘情况： 0/0 或 Infinity/Infinity显示100%
  if (value === maxValue && (value === 0 || value === Infinity)) {
    percent = 100;
  }
  // 其他边缘情况：-Infinity/Infinity，或者value，maxValue不是数字
  else if (Number.isNaN(value / maxValue)) {
    percent = 0;
  } else {
    // 为了保证UI刷新，在超过fomantic-ui的精度阈值时设置为恰好低于阈值。
    percent = percent >= 99.5 && percent < 100 ? 99.49 : percent;
  }
  // fomantic-ui自带的精度只影响百分比显示，显示value精度是固定的，total却又保留原数值（不round），很混乱。
  // 这里直接将value和total都round，然后替换format中的{value}和{total}。
  const active = format
    .replace(/{value}/g, value === Infinity ? '∞' : _.round(value, precision))
    .replace(/{total}/g, maxValue === Infinity ? '∞' : _.round(maxValue, precision));
  element.progress({
    total: maxValue,
    percent,
    text: {
      active,
    },
  });
};
/**
 * @param {import('./combat/实体.js').default} entity
 */
const genCombatLayout = (
  entity,
  parent,
  // TODO: 断言isEnemy=!isPlayer - 目前只有敌人，以后如果有召唤物/队友的话再进行修改
  { isPlayer = false, isEnemy = !isPlayer, config: entityConfig },
) => {
  const html = `
  <div id="${entity.uuid}" class="column">
    <div class="ui segment">
      ${`<h3 class="ui header">${isPlayer ? '你' : entity.职业.name}</h3>`}
      ${isEnemy && entityConfig.isBoss ? labelHTML('BOSS', '', 'yellow') : ''}
      ${isPlayer ? labelHTML('职业', entity.职业.name, 'teal') : ''}
      <div class="ui message">
        <p>${entity.职业.description}</p>
      </div>
      <div class="ui divider"></div>
      ${progressBarHTML({
        className: 'health-bar',
        color: 'red',
      })}
      ${progressBarHTML({
        className: 'mana-bar',
        color: 'blue',
      })}
      ${progressBarHTML({
        className: 'small attack-bar',
        color: 'grey',
      })}
    </div>
  </div>
  `;
  const element = $(html);
  // 初始化进度条
  updateProgressBar(
    element.find('.health-bar'),
    entity.生命值,
    entity.getStat2(StatType.最大生命值),
    config.生命条格式,
  );
  updateProgressBar(
    element.find('.mana-bar'),
    entity.魔法值,
    entity.getStat2(StatType.最大魔法值),
    config.魔法条格式,
  );
  updateProgressBar(
    element.find('.attack-bar'),
    entity.攻击计时器去掉攻速(),
    entity.实际攻击间隔(),
    config.攻击条格式,
    2,
  );
  $(parent).append(element);
};

/**
 * 虽然名字叫'ForStats'，允许传入不是战斗属性的数值。
 * 函数内部会检测'path'是否是实体的属性。
 */
const genElementForStats = (entity, parent, value, key, labelClass = '', path = [key]) => {
  if (_.isObject(value) && !Array.isArray(value)) {
    const label = $(`<div class="ui teal horizontal label">${key}</div>`);
    const child = $(`<div class="ui list"></div>`);
    parent.append(label, child);
    _.forEach(value, (v, k) => {
      genElementForStats(entity, child, v, k, labelClass, [...path, k]);
    });
    return;
  }
  let formatted;
  // 属性成长是一个数组，且不受Buff影响
  // 这里我们断言数组是属性成长，否则是当前属性
  if (Array.isArray(value)) {
    formatted = value.map((v) => _.round(v, 2)).join('+');
  } else {
    const isStat = _.get(entity.stats, path) !== undefined;
    // 如果是实体属性，不要用原始数值。显示buff加成后的数值
    // FIXME: 这里会浪费一些性能，因为已经有base了。getBuffedStat会更好。
    // TODO: 还有，要把getStat的clamp放到getBuffedStat里面，让getBuffStat也接受range参数。
    const valueToUse = isStat ? entity.getStat2(path) : value;
    // 如果是实体属性，精确到成长的小数位数
    let precision;
    if (isStat) {
      const statGrowth = entity.getStatGrowth(path);
      // 成长是0，精确到基础值的小数位数后一位（比如1.5精确到1.50，否则精确到成长值的小数位数
      precision = getDecimalPrecision(statGrowth[1] === 0 ? statGrowth[0] / 10 : statGrowth[1]);
    } else {
      precision = 2; // 默认精确到小数点后两位
    }
    formatted = _.round(valueToUse, precision);
  }
  const html = `
    <div class="item">
      ${labelHTML(key, formatted, labelClass)}
    </div>
    `;
  parent.append(html);
};

const genElementForEquipmentStat = (parent, value, key, labelClass = '', path = [key]) => {
  if (_.isObject(value) && _.isEmpty(value)) {
    return;
  }
  if (_.isObject(value) && !Array.isArray(value)) {
    const label = $(labelHTML(key, '', `teal ${labelClass}`));
    const list = $(`<div class="ui relaxed divided horizontal list"></div>`);
    parent.append(
      $('<div class="ui center aligned segment" style="border:none;"></div>').append(label, list),
    );
    _.forEach(value, (v, k) => {
      genElementForEquipmentStat(list, v, k, labelClass, [...path, k]);
    });
    return;
  }
  if (value === 0) {
    return;
  }
  let formatted;
  if (Array.isArray(value)) {
    formatted = value.map((v) => _.round(v, 2)).join('+');
  } else {
    formatted = _.round(value, 2);
  }
  // Leaf
  const html =
    path.length > 1
      ? `<div class="item">
          ${labelHTML(key, formatted, labelClass)}
         </div>
         `
      : `<div class="ui center aligned segment" style="border:none;">
          ${labelHTML(key, formatted, labelClass)}
         </div>
         `;
  parent.append(html);
};

const genItemHTML = () =>
  `
  <div class="column">
    <div class="ui card">
      <div class="ui image placeholder">
        <div class="square icon image">
        </div>
      </div>
    </div>
  </div>
  `;

const genItem = (item, parent) => {
  const isEquipment = item instanceof 装备;
  const element = $(genItemHTML());
  if (isEquipment) {
    element.css('cursor', 'pointer');
    element.on('click', () => {
      const player = 玩家管理器.getPlayer();
      if (player.拥有装备(item)) {
        item.脱下(player);
      } else {
        item.穿上(player);
      }
    });
  }
  // popup content
  const tempParent = $(`
    <div>
      <h3 class="ui header">${item.name}</h3>
      <div class="ui message">
        <p>${item.description}</p>
      </div>
      <div class="ui horizontal wrapping segments"></div>
      <div class="ui divider"></div>
      <button class="ui button" data-use="丢弃">丢弃</button>
    </div>
    `);
  const grid = tempParent.find('.ui.segments');
  _.forEach(item.stats, (value, key) => {
    genElementForEquipmentStat(grid, value, key, 'small');
  });
  element.attr('data-variation', 'multiline flowing');
  element.attr('data-html', compressHTML(tempParent.html()));
  element.popup({
    hoverable: true,
    delay: {
      show: 30,
      hide: 100,
    },
    onCreate: function onCreate() {
      this.find('.button[data-use="丢弃"]').on('click', () => {
        玩家管理器.getPlayer().dropItem(item);
        $.toast({
          message: `你丢掉了${item.name}。`,
        });
      });
    },
    // inline可以apply local CSS rules，让它看起来更对，但是不会在关闭时自动移除
    // TODO: 在父元素被删除时移除popup
    inline: true,
    lastResort: true,
  });
  // 右键也可以丢弃物品
  element.on('contextmenu', (e) => {
    e.preventDefault();
    const player = 玩家管理器.getPlayer();
    if (isEquipment && player.拥有装备(item)) {
      $.toast({
        title: '危险！',
        class: 'red',
        message: `我禁止了右键丢弃已经穿戴的装备，防止误操作。`,
      });
      return;
    }
    player.dropItem(item);
    $.toast({
      message: `你丢掉了${item.name}。`,
    });
  });
  $(parent).append(element);
};

const genInventory = () => {
  const player = 玩家管理器.getPlayer();
  const 背包面板背包 = $('#背包面板-背包');
  背包面板背包.empty();
  _.forEach(player.背包.items, (item) => {
    genItem(item, 背包面板背包);
  });
};

const genEquipments = () => {
  const player = 玩家管理器.getPlayer();
  const 背包面板装备 = $('#背包面板-装备');
  背包面板装备.empty();
  _.forEach(player.装备, (typeEquipments) => {
    typeEquipments.forEach((equipment) => {
      genItem(equipment, 背包面板装备);
    });
  });
};

export {
  config,
  changeTab,
  labelHTML,
  genLabel,
  genProgressBar,
  updateProgressBar,
  genElementForStats,
  genCombatLayout,
  genItem,
  genEquipments,
  genInventory,
  loadAndRenderMarkdown,
};
